(in-package "ZITO")


(defmethod make-date-widget ((render-type (eql 'html)) label slot-value stream
			     &key (date-label "date") (month-label "month")
			     (year-label "year"))
  (multiple-value-bind (second minute hour date month year day daylight-p zone)
      (decode-universal-time (or slot-value (get-universal-time)))
    (declare (ignore second minute hour day daylight-p zone))
    (with-html-output (s stream)
      ((:select :name date-label)
       (dotimes (i 30)
	 (if (= (1+ i) date)
	     (htm ((:option :selected "selected") (fmt "~D" (1+ i))))
	     (htm (:option (fmt "~D" (1+ i)))))))
      ((:select :name month-label)
       (let ((month-counter 1))
	 (dolist (m '("January" "February" "March" "April" "May"
		      "June" "July" "August" "September" "October"
		      "November" "December"))
	   (if (= month-counter month)
	       (htm ((:option :selected "selected" :value month-counter)
		     (str m)))
	       (htm ((:option :value month-counter)
		     (str m))))
	   (incf month-counter))))
      ((:input :type "text" :name year-label :length "4") (fmt "~A" year)))))

(defun handle-date (object slot-name parameters
		    &key (date-label 'date) (month-label 'month)
		    (year-label 'year))
  (flet ((grab-int (pname)
	   (ignore-errors (parse-integer (assoc pname parameters)))))
    (let ((date (grab-int date-label))
	  (month (grab-int month-label))
	  (year (grab-int year-label)))
      (when (and date month year)
	(let ((vdate (validate-date date month year)))
	  (when vdate
	    (setf (slot-value object slot-name) vdate)))))))

(define-condition bad-date (error)
  ((field :initarg :field :reader field)
   (value :initarg :value :initform nil :reader value)
   (full :initarg :full :reader full)))

(defun validate-date (date month year)
  "Takes integers DATE MONTH YEAR and returns them encoded as a
universal time value if they are valid"
  (flet ((throw-bad-date-error (field value)
	   (error 'bad-date :field field :value value :full (list date month year))))
    (let ((leap-year nil)
 	  (valid-date nil)
	  (valid-month nil))
      (if (mod year 400)
	  (setf leap-year t)
	  (if (mod year 100)
	      (setf leap-year nil)
	      (if (mod year 4)
		  (setf leap-year t))))
      (if (<= 1 month 12)
	  (progn
	    (setf valid-month month)
	    (cond ((member month '(4 6 9 11))
		   (if (<= 1 date 30)
		       (setf valid-date date)
		       (throw-bad-date-error 'date date)))
		  ((= month 2)
		   (if leap-year
		       (if (<= 1 date 29)
			   (setf valid-date date)
			   (throw-bad-date-error 'date date))
		       (if (<= 1 date 28)
			   (setf valid-date date)
			   (throw-bad-date-error 'date date))))
		  (t (if (<= 1 date 31)
			 (setf valid-date date)
			 (throw-bad-date-error 'date date)))))
	  (throw-bad-date-error 'month month))
      (if (and valid-date valid-month year)
	  (encode-universal-time 0 0 0 valid-date valid-month year)
	  (throw-bad-date-error 'total nil)))))